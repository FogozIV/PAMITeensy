//
// Created by fogoz on 25/04/2025.
//

#ifndef REGISTERCOMMANDS_H
#define REGISTERCOMMANDS_H

#include "AX12.h"
#include "CommandParser.h"

#define AX12_CONTROL(address, size, name, writable) AX12_CONTROL_##writable(address, size, name)


#define AX12_CONTROL_false(address, size, name)\
parser.registerCommand("ax12_read_"#name, "i", [robot](std::vector<CommandParser::Argument> arg) {\
    auto ax12 = robot->getAX12Handler()->get(arg[0].asInt64()); \
    return std::to_string(ax12.read##name());\
}, "Autogenerated ax12 control read command for "#name);

#define AX12_CONTROL_true(address, size, name)\
parser.registerCommand("ax12_write_"#name, "ii", [robot](std::vector<CommandParser::Argument> arg) {\
auto ax12 = robot->getAX12Handler()->get(arg[0].asInt64()); \
return std::to_string(ax12.write##name(arg[1].asInt64()));\
}, "Autogenerated ax12 control write command for "#name);\
parser.registerCommand("ax12_read_"#name, "i", [robot](std::vector<CommandParser::Argument> arg) {\
auto ax12 = robot->getAX12Handler()->get(arg[0].asInt64()); \
return std::to_string(ax12.read##name());\
}, "Autogenerated ax12 control read command for "#name);



inline void registerCommands(CommandParser &parser, std::shared_ptr<BaseRobot> robot) {
    parser.registerCommand("hello", "", [](std::vector<CommandParser::Argument> arg) {
        return "hello world !";
    }, "a test command that says hello world");

    parser.registerCommand("help", "", [&parser](std::vector<CommandParser::Argument> arg) {
        std::string result;
        for (CommandParser::Command cmd: parser.command_definitions()) {
            result += cmd.name + ": " + (cmd.description.empty() ? "No description found" : cmd.description) + "\n";
        }
        result.pop_back();
        return result;
    }, "a command that displays all the available commands");

    parser.registerCommand("encoder_calib_rotation_turn", "d", [robot](std::vector<CommandParser::Argument> arg) {
                               robot->endCalibrationAngleTurnEncoder(arg[0].asDouble());
                               return "success";
                           },
                           "a command that allows you to type in the number of turn the robot did and calibrate it automatically don't forget to call encoder_calib_init before calling this function");

    parser.registerCommand("encoder_calib_init", "", [robot](std::vector<CommandParser::Argument> arg) {
        robot->beginCalibrationEncoder();
        return
                "Started the encoder calibration please type encoder_calib_rotation_turn or encoder_calib_straight after moving the robot";
    }, "a command that allows you to start the calibration of the encoder");

    parser.registerCommand("encoder_calib_straight", "d", [robot](std::vector<CommandParser::Argument> arg) {
                               robot->endCalibrationStraightEncoder(arg[0].asDouble());
                               return "success";
                           },
                           "a command that allows you to type in the distance the robot did and calibrate it automatically don't forget to call encoder_calib_init before calling this function");

    parser.registerCommand("calib_motors", "", [robot](std::vector<CommandParser::Argument> args) {
        robot->calibrateMotors();
        return "success";
    }, "a command that allows you to correct the motor wiring internally");

    parser.registerCommand("reset", "", [](std::vector<CommandParser::Argument> arg) {
        SCB_AIRCR = 0x05FA0004;
        while (true);
        return "if you see this there is an issue";
    }, "a command that allows you to reset the robot");

    parser.registerCommand("test_ax12", "i", [robot](std::vector<CommandParser::Argument> arg) {
        auto ax12 = robot->getAX12Handler()->get(arg[0].asInt64());
        std::vector<uint8_t> u = ax12.sendCommand({AX12_INSTRUCTION_PING});
        if (u.size() > 1) {
            Serial.println("Success");
            printAX12Error(u[0], Serial);
        }else {
            Serial.println("Ping failed");
            if (u.size() > 0) {
                Serial.println(u[0]);
            }
        }
        return "done";
    });
    parser.registerCommand("set_left_pwm", "d", [robot](std::vector<CommandParser::Argument> arg){
        robot->getLeftMotor()->setPWM(arg[0].asDouble());
        return "success";
    }, "a command that allows you to set the pwm of the left motor");
    parser.registerCommand("set_right_pwm", "d", [robot](std::vector<CommandParser::Argument> arg){
        robot->getRightMotor()->setPWM(arg[0].asDouble());
        return "success";
    }, "a command that allows you to set the pwm of the right motor");

    parser.registerCommand("disable_control", "i", [robot](std::vector<CommandParser::Argument> args){
        robot->setControlDisabled(args[0].asInt64());
        return "success";
    }, "a command that allows you to disable the motor control");


    AX12_CONTROL_TABLE
}
#endif //REGISTERCOMMANDS_H
