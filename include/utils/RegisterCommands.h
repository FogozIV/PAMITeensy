//
// Created by fogoz on 25/04/2025.
//

#ifndef REGISTERCOMMANDS_H
#define REGISTERCOMMANDS_H
#include <complex>

#include "ramp/CalculatedQuadramp.h"
#include "target/AngleTarget.h"
#include "target/PositionTarget.h"


extern "C" {
#include "FlashTxx.h"		// TLC/T3x/T4x/TMM flash primitives
}
#include <FXUtil.h>
#include "CommandParser.h"

#include "AX12.h"
#include "robot/BaseRobot.h"

#define AX12_CONTROL(address, size, name, writable) AX12_CONTROL_##writable(address, size, name)

extern bool flashing_process;
#define AX12_CONTROL_false(address, size, name)\
parser.registerCommand(F_LOWER("ax12_read_"#name), F_LOWER("i"), [robot](std::vector<CommandParser::Argument> arg, Stream& stream) {\
    auto ax12 = robot->getAX12Handler()->get(arg[0].asInt64()); \
    return String(ax12.read##name());\
}, F("Autogenerated ax12 control read command for "#name));

#define AX12_CONTROL_true(address, size, name)\
parser.registerCommand(F_LOWER("ax12_write_"#name), F_LOWER("ii"), [robot](std::vector<CommandParser::Argument> arg, Stream& stream) {\
auto ax12 = robot->getAX12Handler()->get(arg[0].asInt64()); \
return String(ax12.write##name(arg[1].asInt64()));\
}, F("Autogenerated ax12 control write command for "#name));\
parser.registerCommand(F_LOWER("ax12_read_"#name), F_LOWER("i"), [robot](std::vector<CommandParser::Argument> arg, Stream& stream) {\
auto ax12 = robot->getAX12Handler()->get(arg[0].asInt64()); \
return String(ax12.read##name());\
}, F("Autogenerated ax12 control read command for "#name));

inline void registerCommands(CommandParser &parser, std::shared_ptr<BaseRobot> robot) {
    Serial.println("Registering commands");
    parser.registerCommand(F_LOWER("hello"), F_LOWER(""), [](std::vector<CommandParser::Argument> arg, Stream& stream) {
        return "hello world !";
    }, F("a test command that says hello world"));

    parser.registerCommand(F_LOWER("help"), F_LOWER(""), [&parser](std::vector<CommandParser::Argument> arg, Stream& stream) {
        for (CommandParser::Command cmd: parser.command_definitions()) {
            stream.println((cmd.name + ": " + (cmd.description.empty() ? "No description found" : cmd.description)).c_str());
        }
        return "";
    }, F("a command that displays all the available commands"));

    parser.registerCommand(F_LOWER("encoder_calib_rotation_turn"), F_LOWER("d"), [robot](std::vector<CommandParser::Argument> arg, Stream& stream) {
        robot->endCalibrationAngleTurnEncoder(arg[0].asDouble());
        return "success";
    }, F("a command that allows you to type in the number of turn the robot did and calibrate it automatically don't forget to call encoder_calib_init before calling this function"));

    parser.registerCommand(F_LOWER("encoder_calib_init"), F_LOWER(""), [robot](std::vector<CommandParser::Argument> arg, Stream& stream) {
        robot->beginCalibrationEncoder();
        return F("Started the encoder calibration please type encoder_calib_rotation_turn or encoder_calib_straight after moving the robot");
    }, F("a command that allows you to start the calibration of the encoder"));

    parser.registerCommand(F_LOWER("encoder_calib_straight"), F_LOWER("d"), [robot](std::vector<CommandParser::Argument> arg, Stream& stream) {
        robot->endCalibrationStraightEncoder(arg[0].asDouble());
        return "success";
    },F("a command that allows you to type in the distance the robot did and calibrate it automatically don't forget to call encoder_calib_init before calling this function"));

    parser.registerCommand(F_LOWER("calib_motors"), F_LOWER(""), [robot](std::vector<CommandParser::Argument> args, Stream& stream) {
        robot->calibrateMotors();
        return "success";
    }, F("a command that allows you to correct the motor wiring internally"));

    parser.registerCommand(F_LOWER("reset"), F_LOWER(""), [](std::vector<CommandParser::Argument> arg, Stream& stream) {
        SCB_AIRCR = 0x05FA0004;
        while (true);
        return "if you see this there is an issue";
    }, F("a command that allows you to reset the robot"));

    parser.registerCommand(F_LOWER("test_ax12"), F_LOWER("i"), [robot](std::vector<CommandParser::Argument> arg, Stream& stream) {
        auto ax12 = robot->getAX12Handler()->get(arg[0].asInt64());
        std::vector<uint8_t> u = ax12.sendCommand({AX12_INSTRUCTION_PING});
        if (u.size() > 1) {
            stream.println(F("Success"));
            printAX12Error(u[0], stream);
        }else {
            stream.println(F("Ping failed"));
            if (u.size() > 0) {
                stream.println(u[0]);
            }
        }
        return "done";
    });
    parser.registerCommand(F_LOWER("set_left_pwm"), F_LOWER("d"), [robot](std::vector<CommandParser::Argument> arg, Stream& stream){
        robot->getLeftMotor()->setPWM(arg[0].asDouble());
        return "success";
    }, F("a command that allows you to set the pwm of the left motor"));
    parser.registerCommand(F_LOWER("set_right_pwm"), "d", [robot](std::vector<CommandParser::Argument> arg, Stream& stream){
        robot->getRightMotor()->setPWM(arg[0].asDouble());
        return "success";
    }, F("a command that allows you to set the pwm of the right motor"));

    parser.registerCommand(F_LOWER("disable_control"), "i", [robot](std::vector<CommandParser::Argument> args, Stream& stream){
        robot->setControlDisabled(args[0].asInt64());
        return "success";
    }, F("a command that allows you to disable the motor control"));

    //Interact command
    parser.registerCommand(F_LOWER("interact"), "", [robot](std::vector<CommandParser::Argument> args, Stream& stream){
        stream.println(F("Use arrow key to move (if movement is not in the right direction please use the calib_motors command)"));
        stream.println(F("Use space to stop robot movement"));
        stream.println(F("Use q, Q, w, W to exit the interact"));
        bool controlDisabled = robot->isControlDisabled();
        robot->setControlDisabled(true);
        StateMachine stateMachine;
        double leftPWM = 0;
        double rightPWM = 0;
        double maxPWMLeft = robot->getLeftMotor()->getMaxPWM();
        double maxPWMRight = robot->getRightMotor()->getMaxPWM();
        stateMachine.set(UP_LAST_CHAR, [&]{
            leftPWM += maxPWMLeft * 0.1;
            rightPWM += maxPWMRight * 0.1;
        });
        stateMachine.set(DOWN_LAST_CHAR, [&]{
            leftPWM -= maxPWMLeft * 0.1;
            rightPWM -= maxPWMRight * 0.1;
        });
        stateMachine.set(LEFT_LAST_CHAR, [&]{
            leftPWM -= maxPWMLeft * 0.1;
            rightPWM += maxPWMRight * 0.1;
        });
        stateMachine.set(RIGHT_LAST_CHAR, [&]{
            leftPWM += maxPWMLeft * 0.1;
            rightPWM -= maxPWMRight * 0.1;
        });
        while(true){
            while(stream.available()){
                char c = stream.read();
                if(c == 27){
                    stateMachine.begin();
                    continue;
                }
                if(stateMachine.isStarted()){
                    stateMachine.append(c);
                    if(stateMachine.isStarted()){
                        continue;
                    }
                }
                if(c == 32){
                    leftPWM = 0;
                    rightPWM = 0;
                }

                if(c == 'w' || c=='W' || c=='q' || c=='Q'){
                    robot->getLeftMotor()->setPWM(0);
                    robot->getRightMotor()->setPWM(0);
                    robot->setControlDisabled(controlDisabled);
                    return "Thanks for using interact";
                }
                leftPWM = constrain(leftPWM, -maxPWMLeft, maxPWMLeft);
                rightPWM = constrain(rightPWM, -maxPWMRight, maxPWMRight);
                robot->getLeftMotor()->setPWM(leftPWM);
                robot->getRightMotor()->setPWM(rightPWM);
            }

            Threads::yield();
        }

    });

    parser.registerCommand(F_LOWER("position"), "", [robot](std::vector<CommandParser::Argument> args, Stream& stream){
        stream.print("Robot current pos: ");
        robot->getCurrentPosition().printTo(stream);
        return " ";
    });

    parser.registerCommand(F_LOWER("position_set"), "ddd", [robot](std::vector<CommandParser::Argument> args, Stream& stream){
        robot->reset_to({args[0].asDouble(), args[1].asDouble(), Angle::fromDegrees(args[2].asDouble())});
        return "Position set successfully";
    });

    parser.registerCommand(F_LOWER("flash"), F_LOWER(""), [](std::vector<CommandParser::Argument> args, Stream& stream) {
        stream.print("Beginning the flash : ");
        if (flashing_process) {
            return F("unable to flash another process is already doing it");
        }
        flashing_process = true;
        uint32_t buffer_addr, buffer_size;
        // create flash buffer to hold new firmware
        if (firmware_buffer_init( &buffer_addr, &buffer_size ) == 0) {
          stream.printf( "unable to create buffer\r\n" );
          stream.flush();
            flashing_process = false;
            return F("error");
        }

        stream.printf( F("created buffer = %1luK %s (%08lX - %08lX)\r\n"),
              buffer_size/1024, IN_FLASH(buffer_addr) ? "FLASH" : "RAM",
              buffer_addr, buffer_addr + buffer_size );
        stream.println(F("READY for upload"));
        // read hex file, write new firmware to flash, clean up, reboot
        update_firmware( &stream, &stream, buffer_addr, buffer_size, false);

        firmware_buffer_free(buffer_addr, buffer_size);

        return F("");
    });
    parser.registerCommand(F_LOWER("save"), F_LOWER(""), [robot](std::vector<CommandParser::Argument> args, Stream& stream) {
        robot->save();
        return "The configuration has been saved";
    });
    parser.registerCommand(F_LOWER("rotatetoward"), F_LOWER("ddd"), [robot](std::vector<CommandParser::Argument> args, Stream& stream) {
        robot->addTarget(std::make_shared<AngleTarget<CalculatedQuadramp>>(robot, Angle::fromDegrees(args[0].asDouble()), RampData(args[1].asDouble(), args[2].asDouble())));
        return "";
    });

    parser.registerCommand(F_LOWER("moveToward"), F_LOWER("dddd"), [robot](std::vector<CommandParser::Argument> args, Stream& stream) {
        robot->addTarget(std::make_shared<PositionTarget<CalculatedQuadramp>>(robot, Position(args[0].asDouble(), args[1].asDouble()), RampData(args[2].asDouble(), args[3].asDouble())));
        return "";
    });

    AX12_CONTROL_TABLE
}
#endif //REGISTERCOMMANDS_H
