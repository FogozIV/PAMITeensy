//
// Created by fogoz on 25/04/2025.
//

#ifndef REGISTERCOMMANDS_H
#define REGISTERCOMMANDS_H
extern "C" {
#include "FlashTxx.h"		// TLC/T3x/T4x/TMM flash primitives
}
#include <FXUtil.h>

#include "AX12.h"
#include "CommandParser.h"

#define AX12_CONTROL(address, size, name, writable) AX12_CONTROL_##writable(address, size, name)


#define AX12_CONTROL_false(address, size, name)\
parser.registerCommand("ax12_read_"#name, "i", [robot](std::vector<CommandParser::Argument> arg) {\
    auto ax12 = robot->getAX12Handler()->get(arg[0].asInt64()); \
    return std::to_string(ax12.read##name());\
}, "Autogenerated ax12 control read command for "#name);

#define AX12_CONTROL_true(address, size, name)\
parser.registerCommand("ax12_write_"#name, "ii", [robot](std::vector<CommandParser::Argument> arg) {\
auto ax12 = robot->getAX12Handler()->get(arg[0].asInt64()); \
return std::to_string(ax12.write##name(arg[1].asInt64()));\
}, "Autogenerated ax12 control write command for "#name);\
parser.registerCommand("ax12_read_"#name, "i", [robot](std::vector<CommandParser::Argument> arg) {\
auto ax12 = robot->getAX12Handler()->get(arg[0].asInt64()); \
return std::to_string(ax12.read##name());\
}, "Autogenerated ax12 control read command for "#name);



inline void registerCommands(CommandParser &parser, std::shared_ptr<BaseRobot> robot, Stream &response_stream) {
    parser.registerCommand("hello", "", [](std::vector<CommandParser::Argument> arg) {
        return "hello world !";
    }, "a test command that says hello world");

    parser.registerCommand("help", "", [&parser, &response_stream](std::vector<CommandParser::Argument> arg) {
        for (CommandParser::Command cmd: parser.command_definitions()) {
            response_stream.println((cmd.name + ": " + (cmd.description.empty() ? "No description found" : cmd.description)).c_str());
        }
        return "";
    }, "a command that displays all the available commands");

    parser.registerCommand("encoder_calib_rotation_turn", "d", [robot](std::vector<CommandParser::Argument> arg) {
                               robot->endCalibrationAngleTurnEncoder(arg[0].asDouble());
                               return "success";
                           },
                           "a command that allows you to type in the number of turn the robot did and calibrate it automatically don't forget to call encoder_calib_init before calling this function");

    parser.registerCommand("encoder_calib_init", "", [robot](std::vector<CommandParser::Argument> arg) {
        robot->beginCalibrationEncoder();
        return
                "Started the encoder calibration please type encoder_calib_rotation_turn or encoder_calib_straight after moving the robot";
    }, "a command that allows you to start the calibration of the encoder");

    parser.registerCommand("encoder_calib_straight", "d", [robot](std::vector<CommandParser::Argument> arg) {
                               robot->endCalibrationStraightEncoder(arg[0].asDouble());
                               return "success";
                           },
                           "a command that allows you to type in the distance the robot did and calibrate it automatically don't forget to call encoder_calib_init before calling this function");

    parser.registerCommand("calib_motors", "", [robot](std::vector<CommandParser::Argument> args) {
        robot->calibrateMotors();
        return "success";
    }, "a command that allows you to correct the motor wiring internally");

    parser.registerCommand("reset", "", [](std::vector<CommandParser::Argument> arg) {
        SCB_AIRCR = 0x05FA0004;
        while (true);
        return "if you see this there is an issue";
    }, "a command that allows you to reset the robot");

    parser.registerCommand("test_ax12", "i", [robot, &response_stream](std::vector<CommandParser::Argument> arg) {
        auto ax12 = robot->getAX12Handler()->get(arg[0].asInt64());
        std::vector<uint8_t> u = ax12.sendCommand({AX12_INSTRUCTION_PING});
        if (u.size() > 1) {
            response_stream.println("Success");
            printAX12Error(u[0], response_stream);
        }else {
            response_stream.println("Ping failed");
            if (u.size() > 0) {
                response_stream.println(u[0]);
            }
        }
        return "done";
    });
    parser.registerCommand("set_left_pwm", "d", [robot](std::vector<CommandParser::Argument> arg){
        robot->getLeftMotor()->setPWM(arg[0].asDouble());
        return "success";
    }, "a command that allows you to set the pwm of the left motor");
    parser.registerCommand("set_right_pwm", "d", [robot](std::vector<CommandParser::Argument> arg){
        robot->getRightMotor()->setPWM(arg[0].asDouble());
        return "success";
    }, "a command that allows you to set the pwm of the right motor");

    parser.registerCommand("disable_control", "i", [robot](std::vector<CommandParser::Argument> args){
        robot->setControlDisabled(args[0].asInt64());
        return "success";
    }, "a command that allows you to disable the motor control");

    parser.registerCommand("interact", "", [robot, &response_stream](std::vector<CommandParser::Argument> args){
        response_stream.println("Use arrow key to move (if movement is not in the right direction please use the calib_motors command)");
        response_stream.println("Use space to stop robot movement");
        response_stream.println("Use q, Q, w, W to exit the interact");
        bool controlDisabled = robot->isControlDisabled();
        robot->setControlDisabled(true);
        StateMachine stateMachine;
        double leftPWM = 0;
        double rightPWM = 0;
        double maxPWMLeft = robot->getLeftMotor()->getMaxPWM();
        double maxPWMRight = robot->getRightMotor()->getMaxPWM();
        stateMachine.set(UP_LAST_CHAR, [&]{
            leftPWM += maxPWMLeft * 0.1;
            rightPWM += maxPWMRight * 0.1;
        });
        stateMachine.set(DOWN_LAST_CHAR, [&]{
            leftPWM -= maxPWMLeft * 0.1;
            rightPWM -= maxPWMRight * 0.1;
        });
        stateMachine.set(LEFT_LAST_CHAR, [&]{
            leftPWM -= maxPWMLeft * 0.1;
            rightPWM += maxPWMRight * 0.1;
        });
        stateMachine.set(RIGHT_LAST_CHAR, [&]{
            leftPWM += maxPWMLeft * 0.1;
            rightPWM -= maxPWMRight * 0.1;
        });
        while(true){
            while(response_stream.available()){
                char c = response_stream.read();
                if(c == 27){
                    stateMachine.begin();
                    continue;
                }
                if(stateMachine.isStarted()){
                    stateMachine.append(c);
                    if(stateMachine.isStarted()){
                        continue;
                    }
                }
                if(c == 32){
                    leftPWM = 0;
                    rightPWM = 0;
                }

                if(c == 'w' || c=='W' || c=='q' || c=='Q'){
                    robot->getLeftMotor()->setPWM(0);
                    robot->getRightMotor()->setPWM(0);
                    robot->setControlDisabled(controlDisabled);
                    return "Thanks for using interact";
                }
                leftPWM = constrain(leftPWM, -maxPWMLeft, maxPWMLeft);
                rightPWM = constrain(rightPWM, -maxPWMRight, maxPWMRight);
                robot->getLeftMotor()->setPWM(leftPWM);
                robot->getRightMotor()->setPWM(rightPWM);
            }

            Threads::yield();
        }

    });

    parser.registerCommand("position", "", [robot, &response_stream](std::vector<CommandParser::Argument> args){
        response_stream.print("Robot current pos: ");
        robot->getCurrentPosition().printTo(response_stream);
        return "";
    });

    parser.registerCommand("position_set", "ddd", [robot](std::vector<CommandParser::Argument> args){
        robot->reset_to({args[0].asDouble(), args[1].asDouble(), args[2].asDouble() * DEG_TO_RAD});
        return "Position set successfully";
    });

    parser.registerCommand("flash", "", [&response_stream](std::vector<CommandParser::Argument> args) {
        uint32_t buffer_addr, buffer_size;
        // create flash buffer to hold new firmware
        if (firmware_buffer_init( &buffer_addr, &buffer_size ) == 0) {
          response_stream.printf( "unable to create buffer\r\n" );
          response_stream.flush();
            return "error";
        }

        response_stream.printf( "created buffer = %1luK %s (%08lX - %08lX)\r\n",
              buffer_size/1024, IN_FLASH(buffer_addr) ? "FLASH" : "RAM",
              buffer_addr, buffer_addr + buffer_size );
        response_stream.println("READY for upload");
        // read hex file, write new firmware to flash, clean up, reboot
        update_firmware( &response_stream, &response_stream, buffer_addr, buffer_size, false);

        firmware_buffer_free(buffer_addr, buffer_size);

        return "";
    });

    AX12_CONTROL_TABLE
}
#endif //REGISTERCOMMANDS_H
